#!/usr/bin/env python3
#
# (c) Copyright 2023 by Coinkite Inc. This file is covered by license found in COPYING-CC.
#
# Read in PNG (or even JPG)... output heavily compressed BGR232 data.
#
import os, sys, pdb
from PIL import Image, ImageOps
import zlib
from struct import pack

WBITS = -10

def read_img(fn):
    img = Image.open(fn)
    w,h = img.size
    assert 1 <= w <= 320, f'too wide; {w}'
    assert 1 <= h <= 240, f'too tall: {h}'

    img = img.convert('RGB')

    # maybe: quantitize to a reasonable num colours, so compression
    # can work better?

    return img

def compress(n, wbits=WBITS):
    # NOTE: neg wbits implies no zlib header, and receiver may need to know it?
    z = zlib.compressobj(wbits=wbits, level=zlib.Z_BEST_COMPRESSION)
    rv = z.compress(n)
    rv += z.flush(zlib.Z_FINISH)
    return rv

def crunch(n):
    # try them all... not finding any difference tho.
    a = [(wb,compress(n, wb)) for wb in range(-9, -15, -1)]

    a.sort(key=lambda i: (-len(i[1]), -i[0]))

    print("Wbit values:")
    print('\n'.join("%3d => %d" % (wb,len(d)) for wb,d in a))

    return a[0]

# LCD Display wants RGB565 values, but wrong endian from us, so green gets split weird.
def swizzle(r,g,b):
    # from 0-255 per component => two bytes
    b = (b >> 3)
    g = (g >> 3)        # should be >> 2 for 6 bits; but looks trash?
    r = (r >> 3)

    return pack('<H', ((r<<11) | (g<<6) | b))

# these values tested on real hardware
assert swizzle(255, 0, 0) == b'\x00\xf8'        # red
#assert swizzle(0, 255, 0) == b'\xc0\x0f'        # green (6 bits)
assert swizzle(0, 255, 0) == b'\xc0\x07'        # green (5 bits)
assert swizzle(0, 0, 255) == b'\x1f\x00'        # blue

        
def into_bgr565(img):
    # get the raw bytes needed for this specific display
    rv = bytearray()
    for y in range(img.height):
        for x in range(img.width):
            px = img.getpixel((x, y))
            assert len(px) == 3
            r,g,b = px
            rv.extend(swizzle(r,g,b))

    return rv
    

def doit(outfname, fnames):

    assert outfname.endswith('.py')
    assert outfname != 'compress.py'
    assert fnames, "need some files"

    fp = open(outfname, 'wt')

    fp.write("""\
# autogenerated; don't edit
#
# BGR565 pixel data
#
class Graphics:
    # (w,h, data)

""")

    for fn in fnames:
        img = read_img(fn)

        assert img.mode == 'RGB'

        varname = fn.split('/')[-1].split('.')[0].replace('-', '_')

        w,h = img.size
        raw = into_bgr565(img)
        comp = compress(raw)
        #crunch(raw)

        if 0:
            # is compression better?
            is_comp = len(comp)+8 < len(raw)
        else:
            # disable; taking too much runtime memory
            is_comp = False

        print("    %s = (%d, %d,\n     %r\n    )\n" % (varname, w, h, comp), file=fp)

        print("done: '%s' (%d x %d) => %d raw => %d compressed bytes" % (
                    varname, w, h, len(raw), len(comp)))

    fp.write("\n# EOF\n")

if 1:
    doit(sys.argv[1], sys.argv[2:])
